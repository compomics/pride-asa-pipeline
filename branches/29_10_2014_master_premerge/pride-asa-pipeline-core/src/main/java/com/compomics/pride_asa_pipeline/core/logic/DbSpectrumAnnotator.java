package com.compomics.pride_asa_pipeline.core.logic;

import com.compomics.pride_asa_pipeline.core.config.PropertiesConfigurationHolder;
import com.compomics.pride_asa_pipeline.core.model.MassRecalibrationResult;
import com.compomics.pride_asa_pipeline.core.model.ModificationHolder;
import com.compomics.pride_asa_pipeline.core.model.SpectrumAnnotatorResult;
import com.compomics.pride_asa_pipeline.core.service.DbExperimentService;
import com.compomics.pride_asa_pipeline.core.service.DbModificationService;
import com.compomics.pride_asa_pipeline.core.util.ResourceUtils;
import com.compomics.pride_asa_pipeline.model.Modification;
import java.util.*;
import org.apache.log4j.Logger;
import org.jdom2.JDOMException;
import org.springframework.core.io.Resource;

/**
 * Created by IntelliJ IDEA. User: niels Date: 9/11/11 Time: 13:22 To change
 * this template use File | Settings | File Templates.
 */
public class DbSpectrumAnnotator extends AbstractSpectrumAnnotator<String> {

    private static final Logger LOGGER = Logger.getLogger(DbSpectrumAnnotator.class);
    /**
     * Beans
     */
    private DbExperimentService experimentService;

    /**
     * Getters and setters.
     */
    public DbExperimentService getExperimentService() {
        return experimentService;
    }

    public void setExperimentService(DbExperimentService experimentService) {
        this.experimentService = experimentService;
    }        

    /**
     * Public methods.
     */
    /**
     * Loads the experiment identifications and calculates the systematic mass
     * errors per charge state.
     *
     * @param experimentAccession the experiment accession number
     */
    @Override
    public void initIdentifications(String experimentAccession) {
        areModificationsLoaded = false;

        LOGGER.debug("Creating new SpectrumAnnotatorResult for experiment " + experimentAccession);
        spectrumAnnotatorResult = new SpectrumAnnotatorResult(experimentAccession);

        LOGGER.debug("Loading charge states for experiment " + experimentAccession);
        initChargeStates();

        LOGGER.info("loading identifications for experiment " + experimentAccession);
        loadExperimentIdentifications(experimentAccession);
        LOGGER.debug("Finished loading identifications for experiment " + experimentAccession);

        ///////////////////////////////////////////////////////////////////////
        //FIRST STEP: find the systematic mass error (if there is one)
        //get analyzer data
        analyzerData = experimentService.getAnalyzerData(experimentAccession);
        LOGGER.info("finding systematic mass errors");
        MassRecalibrationResult massRecalibrationResult = findSystematicMassError(identifications.getCompletePeptides());
        LOGGER.debug("Finished finding systematic mass errors:" + "\n" + massRecalibrationResult.toString());
        spectrumAnnotatorResult.setMassRecalibrationResult(massRecalibrationResult);
    }

    /**
     * Adds the pipeline modifications to the ModificationHolder and returns the
     * pride modifications as a set. If the pride modifications are not taken
     * into account, this set is empty.
     *
     * @return the modifications found in pride
     */
    @Override
    public Set<Modification> initModifications() {
        Set<Modification> prideModifications = new HashSet<>();

        //For the solver we need a ModificationHolder (contains all considered modifications)
        modificationHolder = new ModificationHolder();

        //add the pipeline modifications
        Resource modificationsResource = ResourceUtils.getResourceByRelativePath(PropertiesConfigurationHolder.getInstance().getString("modification.pipeline_modifications_file"));
        try {
            modificationHolder.addModifications(pipelineModificationService.loadPipelineModifications(modificationsResource));
        } catch (JDOMException ex) {
            LOGGER.error(ex.getMessage(), ex);
        }

        //add the modifications found in pride for the given experiment
        if (PropertiesConfigurationHolder.getInstance().getBoolean("spectrumannotator.include_pride_modifications")) {
            prideModifications = ((DbModificationService) modificationService).loadExperimentModifications(identifications.getCompletePeptides());
        }

        //update the initialization status
        areModificationsLoaded = true;

        return prideModifications;
    }

    /**
     * Clears the pipeline resources
     */
    @Override
    public void clearPipeline() {
        areModificationsLoaded = false;
        consideredChargeStates = null;
        identifications = null;
        spectrumAnnotatorResult = null;
        analyzerData = null;
        modificationHolder = null;
    }

    /**
     * Clears the result files generated by the pipeline.
     */
    @Override
    public void clearTmpResources() {

//        String path_tmp = PropertiesConfigurationHolder.getInstance().getString("results_path_tmp");
//        File tempDir = new File(path_tmp);
//        try {
//            LOGGER.debug(String.format("clearing tmp resources from folder '%s'", tempDir.getAbsolutePath()));
//            Files.deleteDirectoryContents(tempDir);
//        } catch (IOException e) {
//            LOGGER.error(e.getMessage(), e);
//        }
    }

    /**
     * Private methods
     */
    /**
     * Loads the experiment identifications.
     *
     * @param experimentAccession the experiment accession number
     */
    private void loadExperimentIdentifications(String experimentAccession) {
        //load the identifications for the given experiment
        identifications = experimentService.loadExperimentIdentifications(experimentAccession);
        //update the considered charge states (if necessary)
        experimentService.updateChargeStates(experimentAccession, consideredChargeStates);
    }
}
